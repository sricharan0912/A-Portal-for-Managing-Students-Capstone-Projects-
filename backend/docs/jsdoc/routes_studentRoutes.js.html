<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: routes/studentRoutes.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: routes/studentRoutes.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Student Routes Module
 * 
 * Handles all student-related API endpoints including authentication, profile management,
 * project preferences, group assignments, and evaluations.
 * 
 * Routes are organized in this order:
 * 1. Authentication (signup, login)
 * 2. Static routes (all students, projects, settings)
 * 3. Parameterized routes (specific student operations)
 * 4. Preferences management
 * 5. Group assignments
 * 6. Evaluations
 * 
 * @module routes/studentRoutes
 * @requires express
 * @requires jsonwebtoken
 * @requires ../../db
 * @requires ../../firebaseAdmin
 * @requires ../middleware/authMiddleware
 * @requires ../middleware/validateRequest
 */

import express from "express";
import jwt from "jsonwebtoken";
import db from "../../db.js";
import { auth } from "../../firebaseAdmin.js";
import { verifyToken, verifyRole } from "../middleware/authMiddleware.js";
import { validateStudentSignup, validateStudentLogin } from "../middleware/validateRequest.js";

const router = express.Router();

/**
 * Generate JWT Token for Student
 * 
 * Creates a signed JWT token containing student authentication data.
 * Token expires in 7 days.
 * 
 * @function generateJWT
 * @param {string} uid - Firebase user ID
 * @param {string} email - Student email address
 * @param {string} role - User role (should be 'student')
 * @param {number} studentId - Numeric database student ID
 * @returns {string} Signed JWT token
 * 
 * @example
 * const token = generateJWT('firebase-uid-123', 'student@example.com', 'student', 42);
 */
const generateJWT = (uid, email, role, studentId) => {
  return jwt.sign(
    { uid, email, role, studentId },
    process.env.JWT_SECRET || "your-secret-key",
    { expiresIn: "7d" }
  );
};

// ==================== AUTHENTICATION ====================

/**
 * Student Signup with Firebase
 * 
 * Registers a new student account with Firebase authentication.
 * Creates entries in both users and user_profiles tables.
 * 
 * @route POST /students/signup
 * @group Authentication - Student authentication operations
 * @param {string} email.body.required - Student email address
 * @param {string} idToken.body.required - Firebase ID token
 * @param {string} first_name.body.required - Student first name
 * @param {string} last_name.body.required - Student last name
 * @returns {object} 201 - Success response with token and student data
 * @returns {object} 400 - Email already registered
 * @returns {object} 401 - Invalid Firebase token
 * @returns {object} 500 - Server error
 * 
 * @example
 * POST /students/signup
 * {
 *   "email": "john.doe@example.com",
 *   "idToken": "firebase-id-token...",
 *   "first_name": "John",
 *   "last_name": "Doe"
 * }
 */
router.post("/signup", validateStudentSignup, async (req, res) => {
  try {
    const { email, idToken, first_name, last_name } = req.body;

    // Check if email already exists
    const [existing] = await db.query(
      "SELECT id FROM users WHERE email = ?",
      [email]
    );

    if (existing.length > 0) {
      return res.status(400).json({
        success: false,
        error: "Email already registered",
      });
    }

    // Verify Firebase ID token
    let uid;
    try {
      const decodedToken = await auth.verifyIdToken(idToken);
      uid = decodedToken.uid;
    } catch (err) {
      console.error("Firebase token verification failed:", err);
      return res.status(401).json({
        success: false,
        error: "Invalid or expired Firebase token",
      });
    }

    const connection = await db.getConnection();

    try {
      // ✅ NEW SCHEMA: Insert into users table
      const [userResult] = await connection.query(
        "INSERT INTO users (email, firebase_uid, role, email_verified, status) VALUES (?, ?, 'student', 1, 'active')",
        [email, uid]
      );

      const userId = userResult.insertId;

      // ✅ NEW SCHEMA: Insert into user_profiles table
      const fullName = `${first_name} ${last_name}`.trim();
      await connection.query(
        `INSERT INTO user_profiles 
         (user_id, first_name, last_name, full_name) 
         VALUES (?, ?, ?, ?)`,
        [userId, first_name, last_name, fullName]
      );

      connection.release();

      // Generate JWT token
      const token = generateJWT(uid, email, "student", userId);

      // ✅ BACKWARDS COMPATIBLE RESPONSE
      res.status(201).json({
        success: true,
        message: "Student registered successfully",
        token,
        student: {
          id: userId,           // Numeric ID
          first_name,
          last_name,
          email,
        },
      });
    } catch (err) {
      connection.release();
      throw err;
    }
  } catch (err) {
    console.error("Signup error:", err);

    // Handle database duplicate entry error
    if (err.code === "ER_DUP_ENTRY") {
      return res.status(400).json({
        success: false,
        error: "Email already registered",
      });
    }

    res.status(500).json({
      success: false,
      error: err.message || "Registration failed",
    });
  }
});

/**
 * Student Login with Firebase
 * 
 * Authenticates an existing student using Firebase ID token.
 * Updates last login timestamp and returns JWT token.
 * 
 * @route POST /students/login
 * @group Authentication - Student authentication operations
 * @param {string} email.body.required - Student email address
 * @param {string} idToken.body.required - Firebase ID token
 * @returns {object} 200 - Success response with token and student data
 * @returns {object} 401 - Invalid credentials or token
 * @returns {object} 500 - Server error
 * 
 * @example
 * POST /students/login
 * {
 *   "email": "john.doe@example.com",
 *   "idToken": "firebase-id-token..."
 * }
 */
router.post("/login", validateStudentLogin, async (req, res) => {
  try {
    const { email, idToken } = req.body;

    // Verify Firebase ID token
    let decodedToken;
    try {
      decodedToken = await auth.verifyIdToken(idToken);
    } catch (err) {
      console.error("Firebase token verification failed:", err);
      return res.status(401).json({
        success: false,
        error: "Invalid or expired token",
      });
    }

    const uid = decodedToken.uid;

    // ✅ NEW SCHEMA: Query users + user_profiles
    const [students] = await db.query(
      `SELECT u.id, u.email, u.role,
              p.first_name, p.last_name, p.full_name
       FROM users u
       LEFT JOIN user_profiles p ON u.id = p.user_id
       WHERE u.email = ? AND u.role = 'student' AND u.deleted_at IS NULL`,
      [email]
    );

    if (students.length === 0) {
      return res.status(401).json({
        success: false,
        error: "Student account not found. Please sign up first.",
      });
    }

    const student = students[0];
    const studentId = student.id;

    // Update last_login_at
    await db.query(
      "UPDATE users SET last_login_at = NOW() WHERE id = ?",
      [studentId]
    );

    // Generate JWT token
    const token = generateJWT(uid, email, "student", studentId);

    // ✅ BACKWARDS COMPATIBLE RESPONSE
    res.json({
      success: true,
      message: "Login successful",
      token,
      student: {
        id: studentId,
        first_name: student.first_name,
        last_name: student.last_name,
        email: student.email,
      },
    });
  } catch (err) {
    console.error("Login error:", err);

    res.status(401).json({
      success: false,
      error: "Authentication failed",
    });
  }
});

// ==================== STATIC ROUTES (MUST BE BEFORE PARAMETERIZED ROUTES) ====================

/**
 * Get All Students
 * 
 * Retrieves list of all registered students.
 * Protected route - only accessible by instructors and admins.
 * 
 * IMPORTANT: This route MUST be defined before /:student_id routes to avoid conflicts.
 * 
 * @route GET /students
 * @group Students - Student management operations
 * @security JWT
 * @param {string} authorization.header.required - Bearer token
 * @returns {object} 200 - Success response with array of students
 * @returns {object} 401 - Unauthorized
 * @returns {object} 403 - Forbidden (not instructor/admin)
 * @returns {object} 500 - Server error
 * 
 * @example
 * GET /students
 * Authorization: Bearer &lt;token>
 */
router.get("/", verifyToken, verifyRole(["instructor", "admin"]), async (req, res) => {
  try {
    // ✅ NEW SCHEMA: Query users + user_profiles
    const [students] = await db.query(
      `SELECT u.id, u.email, u.created_at,
              p.first_name, p.last_name, p.full_name
       FROM users u
       LEFT JOIN user_profiles p ON u.id = p.user_id
       WHERE u.role = 'student' AND u.deleted_at IS NULL
       ORDER BY u.created_at DESC`
    );

    // Format for backwards compatibility
    const formattedStudents = students.map(student => ({
      id: student.id,
      first_name: student.first_name,
      last_name: student.last_name,
      email: student.email,
      created_at: student.created_at,
    }));

    res.json({
      success: true,
      data: formattedStudents,
    });
  } catch (err) {
    console.error("Error fetching all students:", err);
    res.status(500).json({
      success: false,
      error: "Failed to fetch students",
    });
  }
});

/**
 * Get Available Projects for Students
 * 
 * Returns all instructor-approved projects that students can browse and select.
 * Public route - no authentication required.
 * 
 * IMPORTANT: This route MUST be defined before /:student_id routes.
 * 
 * @route GET /students/projects
 * @group Projects - Project browsing operations
 * @returns {object} 200 - Success response with approved projects array
 * @returns {object} 500 - Server error
 * 
 * @example
 * GET /students/projects
 */
router.get("/projects", async (req, res) => {
  try {
    // ✅ Query projects that have been approved by instructor
    const [projects] = await db.query(
    `SELECT 
       id,
       owner_id as client_id,
       title,
       description,
       required_skills as skills_required,
       category,
       max_team_size as team_size,
       start_date,
       end_date,
       difficulty_level as complexity_level,
       deliverables,
       location as project_location,
       industry_category as industry,
       status,
       created_at
      FROM projects 
      WHERE approval_status = 'approved'
      ORDER BY created_at DESC`
  );

    res.json({
      success: true,
      data: projects,
    });
  } catch (err) {
    console.error("Error fetching projects:", err);
    res.status(500).json({
      success: false,
      error: "Failed to fetch projects",
    });
  }
});

/**
 * Get Course Settings
 * 
 * Retrieves course settings including preference submission deadline.
 * Public route - students need to see deadline before authentication.
 * 
 * @route GET /students/course-settings
 * @group Settings - Course configuration operations
 * @returns {object} 200 - Success response with course settings
 * @returns {object} 500 - Server error
 * 
 * @example
 * GET /students/course-settings
 * Response: { "success": true, "data": { "preference_deadline": "2025-01-15T23:59:59Z" } }
 */
router.get("/course-settings", async (req, res) => {
  try {
    // Query app_settings table for preference_deadline
    const [result] = await db.query(
      `SELECT setting_key, setting_value FROM app_settings WHERE setting_key = 'preference_deadline'`
    );

    if (result.length > 0) {
      res.json({
        success: true,
        data: {
          preference_deadline: result[0].setting_value,
        },
      });
    } else {
      // No deadline set
      res.json({
        success: true,
        data: {
          preference_deadline: null,
        },
      });
    }
  } catch (err) {
    // If table doesn't exist, return null deadline
    if (err.code === 'ER_NO_SUCH_TABLE') {
      return res.json({
        success: true,
        data: {
          preference_deadline: null,
        },
      });
    }
    console.error("Error fetching course settings:", err);
    res.status(500).json({
      success: false,
      error: "Failed to fetch course settings",
    });
  }
});

// ==================== PARAMETERIZED ROUTES (AFTER STATIC ROUTES) ====================

// ==================== STUDENT PROFILE ====================

/**
 * Get Student Profile
 * 
 * Retrieves profile information for a specific student.
 * Students can view their own profile, instructors/admins can view any profile.
 * 
 * @route GET /students/:student_id
 * @group Students - Student management operations
 * @security JWT
 * @param {number} student_id.path.required - Student ID
 * @param {string} authorization.header.required - Bearer token
 * @returns {object} 200 - Success response with student data
 * @returns {object} 400 - Invalid student ID format
 * @returns {object} 403 - Unauthorized access
 * @returns {object} 404 - Student not found
 * @returns {object} 500 - Server error
 * 
 * @example
 * GET /students/42
 * Authorization: Bearer &lt;token>
 */
router.get("/:student_id", verifyToken, async (req, res) => {
  try {
    const { student_id } = req.params;

    if (isNaN(student_id)) {
      return res.status(400).json({
        success: false,
        error: "Invalid student ID format",
      });
    }

    // Allow students to view their own profile, or instructors/admins to view any profile
    if (
      parseInt(student_id) !== req.user.studentId &amp;&amp; 
      req.user.role !== "instructor" &amp;&amp; 
      req.user.role !== "admin"
    ) {
      return res.status(403).json({
        success: false,
        error: "Unauthorized access",
      });
    }

    // ✅ NEW SCHEMA: Query users + user_profiles
    const [students] = await db.query(
      `SELECT u.id, u.email, u.created_at,
              p.first_name, p.last_name, p.full_name
       FROM users u
       LEFT JOIN user_profiles p ON u.id = p.user_id
       WHERE u.id = ? AND u.role = 'student' AND u.deleted_at IS NULL`,
      [parseInt(student_id)]
    );

    if (students.length === 0) {
      return res.status(404).json({
        success: false,
        error: "Student not found",
      });
    }

    const student = students[0];

    res.json({
      success: true,
      data: {
        id: student.id,
        first_name: student.first_name,
        last_name: student.last_name,
        email: student.email,
        created_at: student.created_at,
      },
    });
  } catch (err) {
    console.error("Error fetching student:", err);
    res.status(500).json({
      success: false,
      error: "Failed to fetch student profile",
    });
  }
});

/**
 * Update Student Profile
 * 
 * Updates student profile information including name and email.
 * Only students can update their own profile, or admins.
 * 
 * @route PUT /students/:student_id
 * @group Students - Student management operations
 * @security JWT
 * @param {number} student_id.path.required - Student ID
 * @param {string} first_name.body.required - Updated first name
 * @param {string} last_name.body.required - Updated last name
 * @param {string} email.body.required - Updated email address
 * @param {string} authorization.header.required - Bearer token
 * @returns {object} 200 - Success response
 * @returns {object} 400 - Validation error or email already in use
 * @returns {object} 403 - Unauthorized access
 * @returns {object} 404 - Student not found
 * @returns {object} 500 - Server error
 * 
 * @example
 * PUT /students/42
 * {
 *   "first_name": "John",
 *   "last_name": "Smith",
 *   "email": "john.smith@example.com"
 * }
 */
router.put("/:student_id", verifyToken, async (req, res) => {
  try {
    const { student_id } = req.params;
    const { first_name, last_name, email } = req.body;

    if (isNaN(student_id)) {
      return res.status(400).json({
        success: false,
        error: "Invalid student ID format",
      });
    }

    // Only students can update their own profile, or admins
    if (parseInt(student_id) !== req.user.studentId &amp;&amp; req.user.role !== "admin") {
      return res.status(403).json({
        success: false,
        error: "Unauthorized access",
      });
    }

    if (!first_name || !last_name || !email) {
      return res.status(400).json({
        success: false,
        error: "First name, last name, and email are required",
      });
    }

    // Check if email already exists (excluding current student)
    const [existingEmail] = await db.query(
      "SELECT id FROM users WHERE email = ? AND id != ? AND deleted_at IS NULL",
      [email, parseInt(student_id)]
    );

    if (existingEmail.length > 0) {
      return res.status(400).json({
        success: false,
        error: "Email already in use",
      });
    }

    const connection = await db.getConnection();

    try {
      // ✅ NEW SCHEMA: Update users table
      await connection.query(
        "UPDATE users SET email = ? WHERE id = ?",
        [email, parseInt(student_id)]
      );

      // ✅ NEW SCHEMA: Update user_profiles table
      const fullName = `${first_name} ${last_name}`.trim();
      const [result] = await connection.query(
        "UPDATE user_profiles SET first_name = ?, last_name = ?, full_name = ? WHERE user_id = ?",
        [first_name, last_name, fullName, parseInt(student_id)]
      );

      connection.release();

      if (result.affectedRows === 0) {
        return res.status(404).json({
          success: false,
          error: "Student not found",
        });
      }

      res.json({
        success: true,
        message: "Student profile updated successfully",
      });
    } catch (err) {
      connection.release();
      throw err;
    }
  } catch (err) {
    console.error("Error updating student:", err);
    res.status(500).json({
      success: false,
      error: "Failed to update student profile",
    });
  }
});

/**
 * Delete Student Account
 * 
 * Soft deletes a student account (sets deleted_at timestamp and status to inactive).
 * Only students can delete their own account, or admins.
 * 
 * @route DELETE /students/:student_id
 * @group Students - Student management operations
 * @security JWT
 * @param {number} student_id.path.required - Student ID
 * @param {string} authorization.header.required - Bearer token
 * @returns {object} 200 - Success response
 * @returns {object} 400 - Invalid student ID format
 * @returns {object} 403 - Unauthorized access
 * @returns {object} 404 - Student not found
 * @returns {object} 500 - Server error
 * 
 * @example
 * DELETE /students/42
 * Authorization: Bearer &lt;token>
 */
router.delete("/:student_id", verifyToken, async (req, res) => {
  try {
    const { student_id } = req.params;

    if (isNaN(student_id)) {
      return res.status(400).json({
        success: false,
        error: "Invalid student ID format",
      });
    }

    // Only students can delete their own account, or admins
    if (parseInt(student_id) !== req.user.studentId &amp;&amp; req.user.role !== "admin") {
      return res.status(403).json({
        success: false,
        error: "Unauthorized access",
      });
    }

    // ✅ NEW SCHEMA: Soft delete using deleted_at
    const [result] = await db.query(
      "UPDATE users SET deleted_at = NOW(), status = 'inactive' WHERE id = ? AND role = 'student'",
      [parseInt(student_id)]
    );

    if (result.affectedRows === 0) {
      return res.status(404).json({
        success: false,
        error: "Student not found",
      });
    }

    res.json({
      success: true,
      message: "Student account deleted successfully",
    });
  } catch (err) {
    console.error("Error deleting student:", err);
    res.status(500).json({
      success: false,
      error: "Failed to delete student account",
    });
  }
});

// ==================== STUDENT PREFERENCES ====================

/**
 * Get Student Preferences
 * 
 * Retrieves student's submitted project preferences with full project details.
 * Returns preferences ordered by rank, along with last updated timestamp and deadline.
 * 
 * @route GET /students/:student_id/preferences
 * @group Preferences - Student preference management
 * @security JWT
 * @param {number} student_id.path.required - Student ID
 * @param {string} authorization.header.required - Bearer token
 * @returns {object} 200 - Success response with preferences, lastUpdated, and deadline
 * @returns {object} 400 - Invalid student ID format
 * @returns {object} 403 - Unauthorized access
 * @returns {object} 500 - Server error
 * 
 * @example
 * GET /students/42/preferences
 * Authorization: Bearer &lt;token>
 */
router.get("/:student_id/preferences", verifyToken, async (req, res) => {
  try {
    const { student_id } = req.params;

    if (isNaN(student_id)) {
      return res.status(400).json({
        success: false,
        error: "Invalid student ID format",
      });
    }

    // Allow students to view their own preferences, or instructors/admins
    if (
      parseInt(student_id) !== req.user.studentId &amp;&amp; 
      req.user.role !== "instructor" &amp;&amp; 
      req.user.role !== "admin"
    ) {
      return res.status(403).json({
        success: false,
        error: "Unauthorized access",
      });
    }

    // ✅ Query with correct column name: preference_rank
    const [preferences] = await db.query(
      `SELECT 
         sp.student_id, 
         sp.project_id, 
         sp.preference_rank,
         sp.updated_at,
         p.title, 
         p.description, 
         p.category, 
         p.difficulty_level as complexity_level,
         p.required_skills as skills_required,
         p.max_team_size as team_size,
         p.start_date, 
         p.end_date,
         p.location as project_location,
         p.deliverables, 
         p.industry_category as industry
       FROM student_preferences sp
       JOIN projects p ON sp.project_id = p.id
       WHERE sp.student_id = ?
       ORDER BY sp.preference_rank ASC`,
      [parseInt(student_id)]
    );

    // Get the most recent updated_at timestamp
    const lastUpdated = preferences.length > 0 
      ? preferences.reduce((latest, pref) => 
          pref.updated_at > latest ? pref.updated_at : latest, 
          preferences[0].updated_at
        )
      : null;

    // Get deadline from database
    const [deadlineResult] = await db.query(
      `SELECT setting_value FROM app_settings WHERE setting_key = 'preference_deadline'`
    );
    const deadline = deadlineResult.length > 0 ? deadlineResult[0].setting_value : null;

    res.json({
      success: true,
      data: preferences,
      lastUpdated,
      deadline,
    });
  } catch (err) {
    console.error("Error fetching preferences:", err);
    res.status(500).json({
      success: false,
      error: "Failed to fetch preferences",
    });
  }
});

/**
 * Submit or Update Student Preferences
 * 
 * Submits or updates student's project preferences (maximum 3).
 * Replaces any existing preferences with the new submission.
 * Checks deadline before allowing submission.
 * 
 * @route POST /students/:student_id/preferences
 * @group Preferences - Student preference management
 * @security JWT
 * @param {number} student_id.path.required - Student ID
 * @param {Array&lt;object>} preferences.body.required - Array of preference objects
 * @param {number} preferences.project_id.required - Project ID
 * @param {number} preferences.preference_rank.required - Rank (1-3, where 1 is highest)
 * @param {string} authorization.header.required - Bearer token
 * @returns {object} 200 - Success response
 * @returns {object} 400 - Validation error or deadline passed
 * @returns {object} 403 - Unauthorized access
 * @returns {object} 500 - Server error
 * 
 * @example
 * POST /students/42/preferences
 * {
 *   "preferences": [
 *     { "project_id": 5, "preference_rank": 1 },
 *     { "project_id": 12, "preference_rank": 2 },
 *     { "project_id": 8, "preference_rank": 3 }
 *   ]
 * }
 */
router.post("/:student_id/preferences", verifyToken, async (req, res) => {
  try {
    const { student_id } = req.params;
    const { preferences } = req.body;

    if (isNaN(student_id)) {
      return res.status(400).json({
        success: false,
        error: "Invalid student ID format",
      });
    }

    // Only students can submit their own preferences
    if (parseInt(student_id) !== req.user.studentId &amp;&amp; req.user.role !== "admin") {
      return res.status(403).json({
        success: false,
        error: "Unauthorized access",
      });
    }

    // Check deadline from database
    const [deadlineResult] = await db.query(
      `SELECT setting_value FROM app_settings WHERE setting_key = 'preference_deadline'`
    );
    const deadline = deadlineResult.length > 0 ? deadlineResult[0].setting_value : null;
    
    if (deadline) {
      const deadlineDate = new Date(deadline);
      const now = new Date();
      if (now > deadlineDate) {
        return res.status(400).json({
          success: false,
          error: "The deadline for submitting preferences has passed",
        });
      }
    }

    if (!Array.isArray(preferences) || preferences.length === 0) {
      return res.status(400).json({
        success: false,
        error: "Preferences must be a non-empty array",
      });
    }

    if (preferences.length > 3) {
      return res.status(400).json({
        success: false,
        error: "Maximum 3 preferences allowed",
      });
    }

    for (const pref of preferences) {
      if (!pref.project_id || !pref.preference_rank) {
        return res.status(400).json({
          success: false,
          error: "Each preference must have project_id and preference_rank",
        });
      }
    }

    // Validate all projects exist
    for (const pref of preferences) {
      const [project] = await db.query(
        "SELECT id FROM projects WHERE id = ?",
        [pref.project_id]
      );

      if (project.length === 0) {
        return res.status(400).json({
          success: false,
          error: `Project with ID ${pref.project_id} not found`,
        });
      }
    }

    const connection = await db.getConnection();

    try {
      // Delete existing preferences
      await connection.query(
        "DELETE FROM student_preferences WHERE student_id = ?",
        [parseInt(student_id)]
      );

      // ✅ Insert with correct column name: preference_rank
      for (const pref of preferences) {
        await connection.query(
          "INSERT INTO student_preferences (student_id, project_id, preference_rank) VALUES (?, ?, ?)",
          [parseInt(student_id), pref.project_id, pref.preference_rank]
        );
      }

      connection.release();

      res.json({
        success: true,
        message: "Preferences submitted successfully",
        data: {
          student_id: parseInt(student_id),
          preferences_count: preferences.length,
        },
      });
    } catch (err) {
      connection.release();
      throw err;
    }
  } catch (err) {
    console.error("Error submitting preferences:", err);
    res.status(500).json({
      success: false,
      error: "Failed to save preferences",
    });
  }
});

/**
 * Clear Student Preferences
 * 
 * Deletes all preferences for a student.
 * Only students can clear their own preferences (or admins).
 * 
 * @route DELETE /students/:student_id/preferences
 * @group Preferences - Student preference management
 * @security JWT
 * @param {number} student_id.path.required - Student ID
 * @param {string} authorization.header.required - Bearer token
 * @returns {object} 200 - Success response with deleted count
 * @returns {object} 400 - Invalid student ID format
 * @returns {object} 403 - Unauthorized access
 * @returns {object} 500 - Server error
 * 
 * @example
 * DELETE /students/42/preferences
 * Authorization: Bearer &lt;token>
 */
router.delete("/:student_id/preferences", verifyToken, async (req, res) => {
  try {
    const { student_id } = req.params;

    if (isNaN(student_id)) {
      return res.status(400).json({
        success: false,
        error: "Invalid student ID format",
      });
    }

    // Only students can clear their own preferences
    if (parseInt(student_id) !== req.user.studentId &amp;&amp; req.user.role !== "admin") {
      return res.status(403).json({
        success: false,
        error: "Unauthorized access",
      });
    }

    const [result] = await db.query(
      "DELETE FROM student_preferences WHERE student_id = ?",
      [parseInt(student_id)]
    );

    res.json({
      success: true,
      message: "Preferences cleared successfully",
      data: {
        deleted_count: result.affectedRows,
      },
    });
  } catch (err) {
    console.error("Error clearing preferences:", err);
    res.status(500).json({
      success: false,
      error: "Failed to clear preferences",
    });
  }
});

// ==================== GROUP ====================

/**
 * Get Student's Assigned Group
 * 
 * Retrieves the group and project assigned to a student.
 * Returns null if student is not yet assigned to a group.
 * 
 * @route GET /students/:student_id/group
 * @group Groups - Student group management
 * @security JWT
 * @param {number} student_id.path.required - Student ID
 * @param {string} authorization.header.required - Bearer token
 * @returns {object} 200 - Success response with group and project data (or null)
 * @returns {object} 400 - Invalid student ID format
 * @returns {object} 403 - Unauthorized access
 * @returns {object} 500 - Server error
 * 
 * @example
 * GET /students/42/group
 * Authorization: Bearer &lt;token>
 */
router.get("/:student_id/group", verifyToken, async (req, res) => {
  try {
    const { student_id } = req.params;

    if (isNaN(student_id)) {
      return res.status(400).json({
        success: false,
        error: "Invalid student ID format",
      });
    }

    // Allow students to view their own group, or instructors/admins
    if (
      parseInt(student_id) !== req.user.studentId &amp;&amp; 
      req.user.role !== "instructor" &amp;&amp; 
      req.user.role !== "admin"
    ) {
      return res.status(403).json({
        success: false,
        error: "Unauthorized access",
      });
    }

    // ✅ NEW SCHEMA: Query with column aliases for backwards compatibility
    const [groupData] = await db.query(
      `SELECT 
         sg.id, 
         sg.group_number, 
         sg.project_id,
         p.id as project_id, 
         p.title, 
         p.description, 
         p.category,
         p.required_skills as skills_required,
         p.difficulty_level as complexity_level,
         p.max_team_size as team_size,
         p.start_date, 
         p.end_date, 
         p.location as project_location,
         p.deliverables, 
         p.industry_category as industry,
         p.status
       FROM group_members gm
       JOIN student_groups sg ON gm.group_id = sg.id
       JOIN projects p ON sg.project_id = p.id
       WHERE gm.student_id = ?`,
      [parseInt(student_id)]
    );

    if (groupData.length === 0) {
      return res.json({
        success: true,
        data: null,
        message: "No group assigned yet",
      });
    }

    res.json({
      success: true,
      data: groupData[0],
    });
  } catch (err) {
    console.error("Error fetching group:", err);
    res.status(500).json({
      success: false,
      error: "Failed to fetch group",
    });
  }
});

/**
 * Get Group Members
 * 
 * Retrieves all members of the student's assigned group.
 * Returns empty array if student is not in a group.
 * 
 * @route GET /students/:student_id/group/members
 * @group Groups - Student group management
 * @security JWT
 * @param {number} student_id.path.required - Student ID
 * @param {string} authorization.header.required - Bearer token
 * @returns {object} 200 - Success response with array of group members
 * @returns {object} 400 - Invalid student ID format
 * @returns {object} 403 - Unauthorized access
 * @returns {object} 500 - Server error
 * 
 * @example
 * GET /students/42/group/members
 * Authorization: Bearer &lt;token>
 */
router.get("/:student_id/group/members", verifyToken, async (req, res) => {
  try {
    const { student_id } = req.params;

    if (isNaN(student_id)) {
      return res.status(400).json({
        success: false,
        error: "Invalid student ID format",
      });
    }

    // Allow students to view their own group members, or instructors/admins
    if (
      parseInt(student_id) !== req.user.studentId &amp;&amp; 
      req.user.role !== "instructor" &amp;&amp; 
      req.user.role !== "admin"
    ) {
      return res.status(403).json({
        success: false,
        error: "Unauthorized access",
      });
    }

    const [groupData] = await db.query(
      `SELECT gm.group_id FROM group_members gm WHERE gm.student_id = ?`,
      [parseInt(student_id)]
    );

    if (groupData.length === 0) {
      return res.json({
        success: true,
        data: [],
        message: "Student not assigned to a group",
      });
    }

    const groupId = groupData[0].group_id;

    // ✅ NEW SCHEMA: Query users + user_profiles for group members
    const [members] = await db.query(
      `SELECT gm.student_id, p.first_name, p.last_name, u.email 
       FROM group_members gm
       JOIN users u ON gm.student_id = u.id
       LEFT JOIN user_profiles p ON u.id = p.user_id
       WHERE gm.group_id = ?
       ORDER BY p.first_name ASC`,
      [groupId]
    );

    res.json({
      success: true,
      data: members,
    });
  } catch (err) {
    console.error("Error fetching group members:", err);
    res.status(500).json({
      success: false,
      error: "Failed to fetch group members",
    });
  }
});

// ==================== EVALUATIONS ====================

/**
 * Get Student Evaluations
 * 
 * Retrieves all evaluations scheduled for the student's group or project.
 * Includes group-specific, project-specific, and general evaluations.
 * Returns empty array if student is not in a group or no evaluations exist.
 * 
 * @route GET /students/:student_id/evaluations
 * @group Evaluations - Student evaluation operations
 * @security JWT
 * @param {number} student_id.path.required - Student ID
 * @param {string} authorization.header.required - Bearer token
 * @returns {object} 200 - Success response with evaluations array
 * @returns {object} 400 - Invalid student ID format
 * @returns {object} 403 - Unauthorized access
 * @returns {object} 500 - Server error
 * 
 * @example
 * GET /students/42/evaluations
 * Authorization: Bearer &lt;token>
 */
router.get("/:student_id/evaluations", verifyToken, async (req, res) => {
  try {
    const { student_id } = req.params;

    if (isNaN(student_id)) {
      return res.status(400).json({
        success: false,
        error: "Invalid student ID format",
      });
    }

    // Allow students to view their own evaluations, or instructors/admins
    if (
      parseInt(student_id) !== req.user.studentId &amp;&amp; 
      req.user.role !== "instructor" &amp;&amp; 
      req.user.role !== "admin"
    ) {
      return res.status(403).json({
        success: false,
        error: "Unauthorized access",
      });
    }

    // First, find the student's group
    const [groupData] = await db.query(
      `SELECT gm.group_id, sg.project_id, sg.group_number 
       FROM group_members gm
       JOIN student_groups sg ON gm.group_id = sg.id
       WHERE gm.student_id = ?`,
      [parseInt(student_id)]
    );

    // If student is not in a group, don't show any evaluations
    if (groupData.length === 0) {
      return res.json({
        success: true,
        data: [],
        message: "Student not assigned to a group yet",
      });
    }

    const groupId = groupData[0].group_id;
    const projectId = groupData[0].project_id;

    // Fetch evaluations for this student's group
    // Include evaluations that:
    // 1. Match the student's specific group_id
    // 2. Match the student's project_id
    // 3. Have group_id = NULL (applies to all groups)
    try {
      const [evaluations] = await db.query(
        `SELECT 
           e.id,
           e.title,
           e.description,
           e.evaluation_type,
           e.scheduled_date,
           e.scheduled_time,
           e.status,
           e.location,
           e.group_id,
           e.project_id,
           p.title as project_title,
           sg.group_number as group_name
         FROM evaluations e
         LEFT JOIN student_groups sg ON e.group_id = sg.id
         LEFT JOIN projects p ON e.project_id = p.id OR sg.project_id = p.id
         WHERE e.group_id = ? 
            OR e.project_id = ?
            OR e.group_id IS NULL
         ORDER BY e.scheduled_date DESC`,
        [groupId, projectId]
      );

      res.json({
        success: true,
        data: evaluations,
      });
    } catch (queryErr) {
      // If evaluations table doesn't exist, return empty array
      if (queryErr.code === 'ER_NO_SUCH_TABLE') {
        console.log("Evaluations table does not exist yet");
        return res.json({
          success: true,
          data: [],
          message: "No evaluations scheduled yet",
        });
      }
      throw queryErr;
    }
  } catch (err) {
    console.error("Error fetching student evaluations:", err);
    res.status(500).json({
      success: false,
      error: "Failed to fetch evaluations",
    });
  }
});

export default router;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-controllers_clientController.html">controllers/clientController</a></li><li><a href="module-controllers_instructorController.html">controllers/instructorController</a></li><li><a href="module-controllers_studentController.html">controllers/studentController</a></li><li><a href="module-groupFormationAlgorithm.html">groupFormationAlgorithm</a></li><li><a href="module-middleware_authMiddleware.html">middleware/authMiddleware</a></li><li><a href="module-routes_clientRoutes.html">routes/clientRoutes</a></li><li><a href="module-routes_evaluationRoutes.html">routes/evaluationRoutes</a></li><li><a href="module-routes_instructorRoutes.html">routes/instructorRoutes</a></li><li><a href="module-routes_projectRoutes.html">routes/projectRoutes</a></li><li><a href="module-routes_studentRoutes.html">routes/studentRoutes</a></li><li><a href="module-utils_groupFormationAlgorithm.html">utils/groupFormationAlgorithm</a></li></ul><h3>Classes</h3><ul><li><a href="AppError.html">AppError</a></li></ul><h3>Global</h3><ul><li><a href="global.html#OPTIONAL_ENV_VARS">OPTIONAL_ENV_VARS</a></li><li><a href="global.html#REQUIRED_ENV_VARS">REQUIRED_ENV_VARS</a></li><li><a href="global.html#calculatePagination">calculatePagination</a></li><li><a href="global.html#errorHandler">errorHandler</a></li><li><a href="global.html#formatAuthError">formatAuthError</a></li><li><a href="global.html#formatConflict">formatConflict</a></li><li><a href="global.html#formatCreated">formatCreated</a></li><li><a href="global.html#formatDeleted">formatDeleted</a></li><li><a href="global.html#formatError">formatError</a></li><li><a href="global.html#formatForbidden">formatForbidden</a></li><li><a href="global.html#formatList">formatList</a></li><li><a href="global.html#formatNotFound">formatNotFound</a></li><li><a href="global.html#formatServerError">formatServerError</a></li><li><a href="global.html#formatSuccess">formatSuccess</a></li><li><a href="global.html#formatUpdated">formatUpdated</a></li><li><a href="global.html#formatValidationError">formatValidationError</a></li><li><a href="global.html#getEnv">getEnv</a></li><li><a href="global.html#isValidEmail">isValidEmail</a></li><li><a href="global.html#isValidUrl">isValidUrl</a></li><li><a href="global.html#mapFirebaseError">mapFirebaseError</a></li><li><a href="global.html#printEnvironmentSummary">printEnvironmentSummary</a></li><li><a href="global.html#printExampleEnvFile">printExampleEnvFile</a></li><li><a href="global.html#requestIdMiddleware">requestIdMiddleware</a></li><li><a href="global.html#requestLoggingMiddleware">requestLoggingMiddleware</a></li><li><a href="global.html#server">server</a></li><li><a href="global.html#validateClientLogin">validateClientLogin</a></li><li><a href="global.html#validateClientSignup">validateClientSignup</a></li><li><a href="global.html#validateDatabaseConfig">validateDatabaseConfig</a></li><li><a href="global.html#validateEnvironment">validateEnvironment</a></li><li><a href="global.html#validateFirebaseConfig">validateFirebaseConfig</a></li><li><a href="global.html#validateGroupAssignment">validateGroupAssignment</a></li><li><a href="global.html#validateInstructorLogin">validateInstructorLogin</a></li><li><a href="global.html#validateInstructorSignup">validateInstructorSignup</a></li><li><a href="global.html#validatePreferences">validatePreferences</a></li><li><a href="global.html#validateProject">validateProject</a></li><li><a href="global.html#validateStudentLogin">validateStudentLogin</a></li><li><a href="global.html#validateStudentSignup">validateStudentSignup</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Mon Dec 22 2025 22:20:27 GMT-0500 (Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
